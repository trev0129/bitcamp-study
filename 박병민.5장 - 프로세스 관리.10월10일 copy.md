# 5장. 프로세스 관리
## 1. 프로세스의 개념

### 프로세스(process)
실행중인 프로그램을 의미하며 디스크에 실행파일 형태로 존재하다 메모리에 올라가 실행되기 시작하면 프로세스가 됨. 잡(job)이라는 단어와 혼용하여 사용함.

### 프로세스 문맥(context) 
프로세스가 현재 어떤 상태에서 수행되는지 규명하기 위한 정보.

- 하드웨어 문맥 : CPU의 수행 상태, 프로그램 카운터값과 각종 레지스터에 저장하고 있는 값들을 의미
- 프로세스 주소 공간 : 프로세스는 코드, 데이터, 스택으로 구성되는 자신만의 독자적인 주소 공간을 가짐
- 커널상의 문맥 : 운영체제는 프로세스를 관리하기 위해 자료구조를 유지하는데, PCB와 커널스택이 이에 해당함


## 2. 프로세스의 상태
### 실행상태(running)
프로세스가 CPU를 보유하고 기계어 명령을 실행하는 상태

### 준비상태(ready)
CPU를 보유하면 명령을 실행할 수 있지만 CPU를 할당 받지 못한 상태

### 봉쇄상태(blocked, wait, sleep)
CPU를 할당 받아도 당장 명령을 실핼할 수 없는 프로세스의 상태
예) 프로세스가 요청한 입출력 작업 진행 중인 경우

→ 프로세스 상태의 구분 이유? 자원의 효율적 관리

### 시작상태(new)
프로세스가 시작되어 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태

### 완료상태(terminated)
프로세스가 종료되었으나 운영체제가 관련된 자료구조를 완전히 정리하지 못한 상태

### 문맥교환(context switch)
실행할 프로세스를 변경하기 위해 **원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정**
문맥교환은 타이머 인터럽트 발생 외에도 프로세스의 입출력 요청 등으로 봉쇄 상태로 바뀌는 경우가 있음.

### CPU 대스패치(dispatch)
분지 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU제어권을 넘겨받는 과정



## 3. 프로세스 제어블록
### 프로세스 제어블록(Process Controll Bolock: PCB)
운영체제가 시스템 내의 프로세스를 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내 자료구조

### PCB의 구성요소
**- 프로세스의 상태(process state)**
CPU할당 여부를 결정하기 위한 상태 정보
**- 프로세스의 카운터(program counter)의 값**
다음에 수행할 명령의 위치
**- CPU 레지스터(CPU ragister)의 값**
CPU연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는가
**- CPU 스케줄링 정보(CPU scheduling infomation)**
프로세스의 CPU스케줄링을 위해 필요한 정보
**- 메모리 관리 정보(memory management infomation)**
프로세스의 메모리 할당을 위해 필요한 정보
**- 자원 사용 정보(accounting infomation)**
사용자에게 자원 사용 요금을 계산해 청구 하는 등의 용도
**- 입출력 상태 정보(I/O status infomation)**
프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보



## 4. 문맥교환
문맥교환이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻함.

CPU를 할당받고 실행되던 중 타이머 인터럽트가 발생하면 CPU제어권이 운영체제에게 넘어가며, 운영체제는 타이머 인터럽트 처리루틴으로가 수행중이던 프로세스의 문맥을 저장하고 다른 프로세스에게 CPU르 이양함.
수행중이던 프로세스는 프로세스의 문맥을 자신의 PCB에 저장하고 준비상태로 바뀌며 새로운 프로세스는 예전에 저장한 자신의 문맥을 CPB로부터 실제 하드웨어로 복원시키는 과정을 거치며 실행상태가 됨.

시스템 콜이나 인터럽트가 발생하여 프로세스가 잠시 멈추고 운영체제 커널의 코드가 실행되는데 이 때 프로세스 문맥 중 일부를 PCB에 저장하지만 이러한 과정은 문맥교환이라 하지 않음. **하나의 프로세스의 실행모드만 사용자모드에서 커널모드로 바뀔 뿐 CPU를 점유하는 프로세스가 변경되지 않기 때문**

모드변경에 비해 문맥교환은 훨씬 많은 오버헤드(overhead)가 뒤따름.

문맥교환에 소요되는 시간은 시스템입장에서 일종의 오버헤드라고 할 수 있음. 문맥교환 중에 일어나는 작업이 시스템에게 유용한 작업이 아니기 때문.


## 5. 프로세스를 스케쥴링하기 위한 큐
운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐(ready queue)를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당함.
준비 큐 이외에도 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 장치 큐(device queue)를 둠.
위에 말한 하드웨어 자원을 기다리는 것이 아닌 소프트웨어 자원을 기다리는 경우에도 자원큐가 필요함. 데이터의 일관성 훼손을 막기 위해 공유 데이터는 매 시점 하나의 프로세스만이 접근할 수 있음.(이 때의 접근이 반드시 CPU가 그 데이터를 사용하고 있음은 아님)

**프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 수행**

운영체제는 준비 큐, 장치 큐 외에 작업 큐(job queue)를 추가로 유지함.

**작업 큐**
- 시스템 내 모든 프로세스를 관리하기 위한 큐, 프로세스의 상태와 무관하게 현재 시스템 애네 있는 모든 프로세스가 작업 큐에 속함.
- 작업 큐에 있다고 반드시 메모리를 가지고 있지 않음.

큐 헤더는 큐의 가장 앞부분을 말하며 큐는 각 프로세스의 PCB를 연결리스트 형태로 관리하며 포인터를 사용해 순서를 정함.



## 6. 스케줄러
스케줄러란 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드

### 장기 스케줄러(long term scheduler)
작업 스케줄러(job scheduler)라고도 부르며, 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할. 준비 큐는 CPU를 얻으면 당장 실행될 수 있는 프로세스의 집합이며, 실행을 위해서는 메모리를 보유해야 하므로 장기 스케줄러는 메모리를 할당하는 문제에 관여함.
처음 프로세스가 생성되면 시작상태를 거쳐 준비상태에 이르는데 이때 시작상태의 프로세스들 중 어떤 것을 준비 큐에 삽입할 것인지 결정하는 역할.

### 단기 스케줄러(short term scheduler)
CPU스케줄러라고도 하며, 준비상태의 프로세스 둥 어떤 프로세스를 다음 실행 상태로 만들 것인지 결정. 즉, 어떤 프로세스에 CPU를 할당할 것인가를 결정함. 시분할 시스템에서는 타이머 인터럽트가 발생하면 단시 스케줄러가 호출됨.

장기 스케줄러는 메모리에 동시에 올라가 있는 프로세스의 수(degree of multiprogramming)를 조절하는 역할. 시작상태의 프로세스에 메모리 할정 승인여부를 결정하기 때문.
→ 현대에는 장기 스케줄러를 두지 않음.

### 중기 스케줄러(medium term scheduling)
너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우를 해결하고자 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러.
메모리에 올라와 있는 프로세스 중 일부를 선정해 메모리를 빼앗아 디스크의 스왑 영역에 저장함. 이를 스왑아웃이라고 함.
프로세스당 메모리양이 지나치게 적어진 경우 이를 완화하기 위해 일부 프로세스를 디스크로 스왑아웃 시키는 역할.

스왑아웃 시켜야 하는 0순위는 봉쇄상태에 있는 프로세스이며, 그래도 부족한 경우 보통 타이머 인터럽트를 발생해 준비큐로 이동하는 프로세스들을 추가로 스왑아웃 시키는 등의 방법을 통해 메모리에 올라와 있는 프로세스의 수를 조정하는 역할 수행

중기스케줄러의 등장으로 프로세스의 상태는 실행, 준비, 봉쇄 외에 **외부적인 이유로 프로세스의 수행이 정지된 상태인 중지상태(suspended, stoped)**가 추가됨.
중지상태는 외부에서 재개하지 않는 이상 다시 활성화 될 수 없으므로 메모리 자원이 당장 필요하지 않아 스왑아웃 됨.
중지상태는 중지준비 상태와 중지봉쇄 상태로 세분화되는데 준비 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑아웃되면 준비중지 상태가 되고 봉쇄상태에서 스왑 아웃되면 중지봉쇄 상태가 됨.
중지봉쇄 상태이던 프로세스가 봉쇄되었던 조건을 만족하면 중지준비 상태로 바뀜.



## 7. 프로세스의 생성
최초의 프로세스는 운영체제가 직접 생성하지만 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다.
- `부모 프로세스` : 프로세스를 생성한 프로세스
- `자식 프로세스` : 생성된 프로세스

- 프로세스는 `부모 프로세스`가 `자식 프로세스`를 생성하는 방식이다. 
    
- 프로세스는 PCB에 저장된 __PID__ _process identifier_ 값을 통해서 식별되고 관리된다.
- 프로세스는 자원이 필요한데, 자원은 운영체제로부터 받거나 부모와 공유한다. 

### 자원 공유 _Resource sharing option_
- 부모와 자식이 모든 자원을 `공유`하는 모델
- 부모와 자식이 자원의 일부를 공유하는 모델
- 전혀 공유하지 않는 모델

### 수행 _Execution_
- 부모와 자식이 공존하며 `동시 수행`돠는 모델
- 자식이 종료될 때까지 부모가 기다리는 모델

### 주소 공간 _Address space_
- 자식이 부모의 공간을 `복제`하는 모델
- 자식이 해당 공간에 새로운 프로그램을 올리는 모델
 
 이와 같이 프로세스는 각 특성마다 이 세가지로 분류된다.

### 프로세스의 종료
#### 자발적 종료
프로세스가 마지막 명령을 수행한 후 os에게 이를 알려 이루어짐.
- 프로세스는 `명령` _instruction_ 을 모두 수행한 후, 프로그램이 마쳐지는 코드 부분에 `exit()`라는 시스템 콜을 넣어주도록 되어 있다.
- 시스템 콜을 통해 자신이 종료됨을 알림
- 종료를 통보받은 os는 이 프로세스로부터 자원을 회수하고 시스템 내에서 이 프로세스를 정리

`exit() 함수`는 프로그램 개발자가 명시적으로 호출하지 않아도 프로그램이 종료되는 지점에 컴파일러가 자동으로 삽입해 프로세스의 `종료 직전`에 항상 호출된다.

#### 비자발적 종료
부모 프로세스가 자식 프로세스의 수행을 `강제 종료` 시키는 것.
- 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양을 요구할 때
- 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때
- 부모 프로세스가 종료되는 경우 -> 단계적인 종료 발생

 자식 프로세스는 부모 프로세스의 처움부터 수행을 시작하는 것이 아니라 부모 프로세스가 현재 수행한 시점(프로그램 카운터 지점)부터 수행하게 된다.

 다만, os가 프로세스를 관리하기 위해서 사용하는 프로세스 식별자는 부모 프로세스와 다른 식별자를 가지게 된다는 점이 유일한 차이점.

- - -

## 8. 프로세스간의 협력
프로세스간의 협력 메커니즘을 위해 운영체제가 제공하는 대표적인 메커니즘으로는
`IPC` _Inter-Process Communication_가 있다.

### IPC 
- 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신
- 프로세스들 간의 `통신` _communication_ 과 `동기화`를 이루기 위한 메커니즘을 의미

<br>

#### 1) 메시지 전달 방식 _message passing_
프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고 받으면서 통신하는 방식
- 메시지 직접 전달 불가해 `커널`이 그 역할을 함
- 커널에 의해 send와 receive 두 가지 연산을 제공 받게 됨
   
    - 이 두 연산을 통해 운영체제에게 시스템 콜 방식으로 요청해 전달
    
<br>    

- `직접 통신` _direct communication_

    
    - 통신하려는 프로세스의 이름을 명시적으로 표시
   
    - `send` ( `P`, message ) 는 프로세스 `P`에게 메시지를 전송
   
    - `receive` ( `Q`, message ) 는 프로세스 `Q`로부터 메시지를 전달 받는 것
   
    - 링크는 자동적으로 생성
   
    - 하나의 링크는 정확히 한 쌍의 프로세스에게 할당
   
    - 각 쌍의 프로세스에는 오직 하나의 링크만이 존재
   
    - 링크는 `단방향성`_unidirectional_일 수 있으나 대부분 `양방향성` _bidirectioal_
    
    
- `간접 통신` _indirect communication_
   
   - `메일박스` 또는 `포트`로부터 전달
   - 각 메일박스에는 `고유의 ID`가 있으며 메일박스를 공유하는 프로세스들만 서로 통신 가능
   - 간접통신에서 사용되는 `커뮤니케이션 링크`는 프로세스 간에 메일박스를 공유하는 경우에만 생성
   - 하나의 링크가 여러 프로세스들에게 할당될 수 있으며 여러 링크가 공유 가능
   - 링크는 `단방향성`이나 `양방향성`일 수 있음
      <br>
     - 새로운 메일박스를 `생성`하는 연산
     - 메일박스를 통한 메시지의 `send()` / `recieve()` 연산
     - 메일박스를 `삭제`하는 연산 등이 사용 가능
  
이 두 가지 방식의 차이는 연산 인터페이스에 대한 차이일 뿐 실제 메시지 전송이 이루어지는 내부 구현은 동일한 방식으로 이루어진다.



#### 2) 공유 메모리 방식 _shared memory_
프로세스들이 주소 공간의 일부를 공유

- 여러 프로세스가 읽고 쓰는 것이 가능

- 프로세스 A, B가 독자적인 주소 공간을 가지고 있지만 이 주소 공간이 물리적 메모리에 `매핑`될 때 공유메모리 주소 영역에 대해서는 동일한 물리적 메모리 주소로 `매핑`
- 통신을 수월하게 만드는 `인터페이스`를 제공
- 커널이 책임지지 않기에 프로세스들끼리 직접 공유메모리 접근에 대한 동기화 문제를 책임져야 함



 IPC의 대표적인 방법으로는 두 가지 방식이 있는데 두 방식의 차이점은 프로세스 사이에 
`공유 데이터`_shared data_를 사용하는가, 그렇지 않은가에 있다.