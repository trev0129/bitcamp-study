# 2장 운영체제 개요

## 1. 운영체제의 정의

운영체제(operating system)란 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어를 말한다. 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.

Operating System에 System이라는 용어는 기반이나 틀이 되는 하드웨어에 붙는데, 하드워가 운영체제와 한 몸이 되어야만 하기 때문이다. 전원을 켰을 때 운영체제가 없으면 그 컴퓨터는 고철에 불과하다.

소프트웨어가 컴퓨터 시스템에서 실행되기 위해서는 메모리에 그 프로그램이 올라가야 한다. 운영체제도 소프트웨어이기 때문에 메모리에 올라가야하지만 전체가 올라가기엔 크기도 크고 공간 낭비가 심하다.

이를 해결하기 위해 항상 필요한 부분만 전원이 켜짐과 동시에 올리고 아닌 부분은 필요할 때 메모리로 올려서 사용한다. 메모리에 상주하는 운영체제의 부분을 커널(kernel)이라 부르며 이를 좁은 의미의 운영체제라 부른다. 즉, 커널은 운영체제 코드중에서도 핵심적인 부분이다.

넓은 의미의 운영체제는 시스템을 위한 유틸리티를 광범위하게 포함하는 개념이다(MS 윈도우 환경에서의 파일 복사). 이와 같은 유틸리티들은 항상 메모리에 올라가 있는 것이 아닌 별도의 프로그램으로서, 시스템을 위한 유틸리티로 운영체제와 함께 설치되기 때문에 넓은 의미에서 포함시킨다.

## 2. 운영체제의 기능

운영체제의 역할은 하드웨어 쪽에서 사용자가 직접 다루기 힘든 하드웨어 관리 위한 역할과 사용자를 위해 편리한 인터페이스를 제공하는 역할 두 가지로 나누어 볼 수 있다.

운영체제의 두 가지 주요 기능은 컴퓨터 시스템 내의 자원(resource)을 효율적으로 관리하는 것과 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하는 것이다. 편리한 환경 제공이란 운영체제가 여러 사용자 및 프로그램들에게 각각 독자적으로 컴퓨터를 사용하는 것과 같은 ‘환상'을 제공하는 것이다.

사용자에게 편리한 환경을 제공하는 것 보다 중요한 핵심 기능은 컴퓨터 시스템 내의 자원을 효율적으로 관리하는 것이다. 그래서 운영체제를 자원관리자(resource manager)라 하기도 한다.

여기서 말하는 자원이란 CPU, Memory, HDD 등 하드웨어 자원뿐만하니라 소프트웨어 자원까지를 통칭하는 말이다.

자원들을 효육적으로 관리해 가장 좋은 성능을 내도록 하는 역할을 담당하는데, 전체적인 성능향상과 더불어 사용자 및 프로그램들 간에 자원이 형평성 있게 분배되도록 균형자의 역할도 함께 수행해야 한다.

이 밖에도 운영체제는 사용자와 운영체제 자신을 보호하는 보안 및 보호기능도 수행한다.

## 3. 운영체제의 분류

동시작업의 지원 여부에 따라 단일작업(single tasking)용 운영체제와 다중작업(multi tasking)용 운영체제로 나눌 수 있다.

단일작업용 운영체제는 한 번에 하나의 프로그램만 실행시킬 수 있는 운영체제로, 초창기에 주로 사용됐다. MS 윈도우가 나오기 전인 도스(Disk Operating System; DOS) 환경은 하나의 프로그램이 실행되는 동안 다른 프로그램을 실행시킬 수 있는 입력라인이 뜨지 않나 하나만 실행 가능하다. 최근에는 대부분 다중작업용 운영체제로 이루어져 있다.

다중작업용 운영체제에서 다중작업을 처리할 때에는 여러 프로그램이 CPU와 메모리를 공유하게 된다. CPU는 하나밖에 없지만 밀리초 단위로 여러 프로그램에서 번갈아 실행하여 사용자 입장에서는 동시에 실행되는 것처럼 보인다. 이와같이 CPU의 작업시간을 여러 프로그램들이 조금씩 나누어쓰는 시스템을 시분할(time sharing system)이라 한다.

메모리는 CPU와 달리 여러 프로그램들이 조금씩 메모리 공간을 분할받아 처리하는데, 이러한 시스템을 다중프로그래밍 시스템(multi-programming system)이라 한다.

다중작업용 운영체제에서 여러프로그램을 같이 실행시키지만 사용자 개개인의 관점에서는 각 프로그램에 대한 키보드 입력의 결과를 곧바로 화면에 보여주기 떄문에 이러한 시스템을 대화형 시스템(interacive system)이라 부른다.

앞서 말한 용어들은 각 프로그램이 사용자의 입력에 곧바로 응답한다는 측면에서 유사한 의미로 사용되며 일반적인 PC가 이러한 조건을 만족한다. 하지만 다중처리기 시스템(multi-precessor system)은 하나의 컴퓨터 안에 CPU가 여러 개 설치된 경우를 뜻해 의미가 다르다.

서로 다른CPU에서 여러프로그램이 실행되어 처리는 빨라지지만, 운영체제 입장에선 여러 CPU 관리를 위해 더 복잡한 메커니즘을 필요로 한다.

운영체제를 분류하는 또 다른 기준으로 다중 사용자 동시지원 여부에 따라 구분된다. 

한 번에 한 명의 사용자만 사용하도록 허용하는 운영체제는 단일 사용자용 운영체제, 여러사용자가 동시에 접속해 사용할 수 있는 운영체제를 다중 사용자용 운영체제라고 한다.

이메일 서버나 웹서버 등 서버라고 부르는 컴퓨터는 다중 사용자용 운영체제의 대표적 예시이다.

단일 사용자용 운영체제는 도스 처럼 한 번에 하나의 작업만 수행하거나, MS 윈도우처럼 혼자 사용하지만 다중 작업이 가능한 경우로 나뉜다.

또한 운영체제는 작업 처리 방식에 따라 나뉘어진다. 일괄처리(batch processing) 방식은 요청된 작업을 일정량씩 모아 한꺼번에 처리하고, 모든 작업이 완전히 종료된 후에 결과를 얻을 수 있다. 사용자 입장에서는 응답시간이 길게 느껴진다. 예시로 초창기 컴퓨터에 사용된 펀치카드(punch card)처리 시스템이 있다.

시분할 방식은 여러 작업을 수행할 때 컴퓨터의 처리능력을 일정한 시간 단위로 분할해 사용하는 방식이다. 여러 사용자의 작업을 짧은 시간 단위씩 번갈아가며 처리해 사용자 입장에서 컴퓨터를 독접하는 듯한 느낌을 받게 한다. 사용자의 요청에 대한 결과를 곧바로 얻는 시스템을 대화형 시스템이라 하며 시분할 방식의 대표적인 특징이다.

실시간(real time)운영체제는 정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장해야 하는 시스템에서 사용된다. 일정 시간 안에 작업이 완료되지 못할 경우에는 동작 자체가 되지 않거나 큰 위험을 초래할 가능성이 있는 시스템에서 사용된다고 볼 수 있다.

실시간 시스템은 시간 제약의 중요성에 따라 경성 실시간 시스템(hard realtime system)과 연성 실시간 시스템(soft realtime system)으로 세분화 된다.

경성 실시간 시스템은 주어진 시간을 지키지 못할 경우 매우 위험한 결과를 초래할 가능성이 있는 로켓, 원자로 제어 시스템 등을 말한다.

연성 실시간 시스템은 멀티미디어 스트리밍 시스템과 같이 데이터가 정해진 시간 단위로 전달되어야 올바른 기능을 수행하는 시스템을 말한다. 시간이 지켜지지 않으면 내용이 정확히 전달되지 않거나 영상이 끊기는 우려가 있지만 위험한 결과를 초래하진 않는다.

## 4. 운영체제의 예

MS 윈도우는 MS-DOS와 윈도우 3.1을 발전시킨 개인용 컴퓨터를 위한 운영체제인다. MS-DOS는 초보자가 사용하기 어려운 명령어 입력방식이었다. 초기 윈도우는 그래픽 인터페이스와 마우스 기능을 지원하여 편리한 환경을 제공했지만, 독립적인 웅영체제가 아닌 MS-DOS위에 수행된다는 점에서 한계가 있었다.

윈도우3.1에서 다중 작업을 비롯한 여러 기능을 지원하였으나 운영체제가 아닌 DOS위에서 수행되는 프로그램이라는 한계는 여전했으며, 윈도우와 함께 DOS도 사용해야하는 어려움이 있었다.

윈도우95에서 온전한 운영체제 위에 프로그램을 수행하게 되며 윈도우98을 거쳐 XP, Vista, 7, 10, 11에 이르렀다.

윈도우 XP부터 인터페이스에서 그래픽 환경과 아이콘 방식을 채택하며 동일한 명령어에 여러 수행방식을 지원해 다루기 편리해졌다.

MS 윈도우의 특징으로 플러그 앤 플레이(plug and play)가 있는데, 시스템에 새로운 하드웨어 장착 시 운영체제가 자동으로 감지하여 하드웨어에 맞게 설정된다.

MS 윈도우는 자체적인 네트워크 프로그램을 지원사기 때문에 윈도우 사용자간 파일 공유와 프린터 등의 하드웨어를 공유할 수 있는 기능을 가지고 있다.

MS 윈도우는 유닉스와 같은 오래된 운영체제에 비해 안정성이 떨어지지만, 사용이 편리한 여러 기능을 지원해 일반 사용자에게 보편적으로 사용되고 있다. 

MS 윈도우 중 높은 안정성으로 웹서버 등 다중 사용자용 운영체제로 사용되는 버전으로 윈도우 NT가 있다. 인터페이스 측면에서 개인용 MS 윈도우와 유사해 편리하나 서버환경을 지원해 웹서버, 전자우편, 파일서버, 데이터베이스 및 통신 기능을 손쉽게 관리할 수 있게 해주는 장점이 있따.

유닉스 운영체제는 1969년 벨 연구소에서 최초로 개발하였다. 유닉스는 프로그램 개발 환경을 위해 개발된 운영체제로서 이식성(portability)이 좋고, 커널의 크기가 작으며, 소스코드(source code)가 공개되었다는 점에서 가장 널리 사용되는 운영체제 중 하나이다.

소프트웨어의 이식성이란 해당 소프트웨어를 다른 기종에 옮기는데 얼마나 용이한가를 나타내는 지표로서 유닉스는 이식성이 높은 최초의 운영체제이다.

그 당시 대부분의 운영체제가 어셈블리 언어로 작성되었으나 유닉스는 대부분의 코드가 C 언어로 작성되어 소스코드를 이해하기 쉽고 다른 기종에 이식하기도 용이했다.

유닉스를 활영해 리눅스 또한 등장했다.

## 5. 운영체제의 자원 관리 기능

운영체제의 핵심 기능으로 자원의 효율적 관리가 있으며 여기서 자원은 하드웨어 자원과 소프트웨어 자원으로 나뉜다.

하드웨어 자원은 CPU와 Memory를 비롯한 주변장치 또는 입출력 장치라 불리는 장치들로 구성된다. 

CPU와 메모리는 전원이 꺼지면 처리중인 정보가 지워지기 때문에 전원에 상관없이 기억해야 하는 부분을 입출력장치 중 하나인 보조기억장치에 파일 형태로 저장한다. 파일에 저장되는 방식과 접근 권한 등도 운영체제가 관리해 주어야 한다.

보조기억장치의 대표적인 매체로 하드디스크가 있으며 키보드, 모니터 등이 입출력 장치로 운영체제의 관리 대상에 포함된다.

매 시점 어떠한 프로세스에 CPU를 할당해 작업을 처리할 것인지 결정하는 일을 **CPU 스케쥴링(CPU scheduling)**이라 한다. CPU 스케쥴링의 목표는 CPU를 효율적으로 사용하면서 특정 프로세스가 불이익을 당하지 않도록 하는 것이다.

**선입선출(First Come Fisrt Served; FCFS) 기법**은 CPU 사용을 위해 도착한 프로세스들을 먼저 온 순서대로 처리하는 것이다. CPU를 먼저 얻은 프로세스가 작업을 완료하는 동안 다른 프로세스는 CPU를 사용하지 못한다. CPU의 효율적 사용은 문제 없지만 전체 시스템 입장에서 비효율 적이다.

특히 장시간 CPU를 사용해야 하는 프로세스가 먼저 도착할 경우 그 단점이 두드러진다.

이를 보완하고자 나온게 **라운드 로빈(Round Robin) 기법**인데, CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한하여 긴 시간 작업을 요하는 경우에도 정해진 시간이 지나면 CPU를 내어놓고 대기열 맨 뒤로 줄을 서야 한다.

**우선순위(priority) 스케줄링**에서는 CPU 사용을 위해 대기중인 프로세스들에 우선순위를 부여하고 상대적으로 중요한 프로세스에 CPU를 먼저 할당한다.

또한 기다린 시간이 늘어날수록 우선순위를 점차 놓여주는 방안도 활용할 수 있다.

운영체제의  또 다른 중요 관리 대상으로 메모리가 있는데, CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치이다. 프로그램이 PC에서 실행되려면 해당 부분이 메모리에 올라가 있어야 한다.

운영체제는 메모리 관리를 위해 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 파악하여 이를 유지하게 되는데, 이러한 정보는 주소(address)를 통해 관리된다.

프로그램에 메모리가 필요할 때 할당하고, 더 이상 필요하지 않을 때 회수한다.

전체 메모리 공간이 효율적으로 사용될 수 있도록 해야 하고 다른 프로세스의 영역을 침범하지 않도록 보안을 유지하는 역할도 운영체제의 몫이다.

**물리적 메모리를 관리하는 방식**에는 고정분할(fixed partition) 방식, 가변분할(variable partition) 방식, 가상메모리(virtual memory) 방식 등이 있다.

**고정분할 방식**은 물리적 메모리를 몇 개의 분할로 미리 나누어 관리하는 방식이다. 메모리에 동시 적재되는 최대 프로그램의 횟수가 정해지기 때문에 융통성이 없다. 

분할이 고정적이라 메모리 분할보다 프로그램 크기가 클 경우 남는 영역이 발생하는데 이 것을 **내부조각(internal fragmentation)**이라 한다. 내부 조각은 해당 프로그램도 다른 프로그램도 사용할 수 없다.

**가변분할 방식**은 매 시점 프로그램의 크기에 맞게 메모리를 분할해 사용하는 방식이다. 따라서 분할 크기 때문에 큰 프로그램 실행이 제한되는 문제가 해결된다. 분할희 크기와 프로그램 개수가 변하므로 기술적 관리가 필요하다.

가변분할에서는 내부조각은 발생하지 않지만 외부조각은 발생할 수 있다. **외부조각(external fragmentation)**이란 프로그램에 할당되지 않았지만 크기가 작아 프로그램을 올리지 못한 메모리 영역을 말한다.

**가상메모리 기법**은 현대의 범용 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법이다. 이는 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원하며 실행될 수 있는 프로그램의 크기는 가상메모리의 크기에 의해 결정된다.

모든 프로그램은 물리적 메모리와는 독립적으로 0번지부터 시작하는 자신만의 가상메모리 주소를 가진다. 운영체제는 이 가상메모리 주소를 물리적 메모리 주소로 매핑(mapping) 하여 주소를 변환시킨 후 프로그램을 물리적 메모리에 올린다. 

현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식을 취한다. 이때 사용되는 보조기억장치의 영역을  **스왑영역(swap area)**이라 부른다.

프로그램을 구성하는 가상 메모리 주소 공간은 **페이지(page)라는 동일한 크기의 작은 단위**로 나뉘어 물리적 메모리와 스왑영역에 일부분씩 저장된다. 동일한 단위로 메모리를 나누는 기법이 **페이징(pageing) 기법**이다.

**주변장치 및 입출력 장치**는 CPU나 메모리와 달리 **인터럽트(interrupt)라는 메커니즘을 통해 관리**된다.

주변장치들은 CPU의 서비스가 필요로 할 때 신호를 발생시켜 서비스를 요청하는데 이 신호가 인터럽트이다.

CPU는 CPU스케줄링에 따라 작업을 수행하다 인터럽트가 발생하면 하던 일을 잠시 멈추고 인터럽트의 요청 서비스를 수행한다.

운영체제는 인터럽트를 처리한 후 원래 수행하던 작업으로 돌아오기 위해 인터럽트 처리 직전에 수행 중이던 작업의 상태를 저장해준다.

인터럽트는 요청하는 장치와 발행 상황에 따라 다양한 종류가 있기 때문에 운영체제는 종류별 인터럽트 처리루틴을 가지고 있다. 인터럽트 처리루틴이란 인터럽트가 발행했을 때 해줘야 할 작업을 정의한 프로그램 코드인다.

인터럽트 처리루틴은 운영체제 커널 내에 존재하는 코드로 CPU스케줄링, 메모리 관리루틴 등 다양한 기능을 위한 커널 코드의 일부분이라 할 수 있다.

주변장치는 각 장치마다 그 장치에서 일어나는 업무를 관리하기 위한 일종의 작은 CPU를 가지고 있는데, 이를 **컨트롤러(comtroller, 제어기)**라고 한다. 컨트롤러는 해당 장치에 대한 업무를 처리하고, 이를 메인 CPU에 인터럽트를 발생시켜 보고하는 역할을 한다.

컨트롤러는 해당 장치에 대한 업무를 처리하고, 메인 CPU에 인터럽트를 발생시켜 보고하는 역할을 한다.