# 운영체제와 정보기술의 관리 7장 메모리 관리

# 4. 페이징 기법
프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식.
페이징 기법에서는 물리적 메모리를 페이지와 동일한 크기의 프레임으로 미리 나누어 둠. 이를 통해 연속할당에서 발생했던 동적 메모리 할당 문제가 발생하지 않음.
페이징 기법에서는 모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블(page table)을 가지며, 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 사지고 있음.
페이징 기법은 외부조각에 문제가 생기진 않으나, 프로그램의 크기가 항상 페이지 크기의 배수가 아니다 보니 마지막 페이지는 내부조각이 발생할 가능성이 있음.

## 1) 주소 변환 기법(address translation)?
CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환에 사용함.
페이지 번호는 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 인덱스로 사용, 인텍스의 항목(entry)에는 그 페이지의 물리적 메모리상의 기준주소(시작위치)가 저장됨.
페이지 오프셋은 하나의 페이지 내에서의 변위(displacement)를 알려줌. 기준 주소값에 변위를 더함으로써 요청된 논리적 주소에 대응하는 물리적 주소를 얻음.

## 2) 페이지 테이블 구현
페이지 테이블은 페이징 기법에서 주소 변환을 하기 위한 자료구조, 물리적 메모리에 위치함.
CPU에서 실행중인 프로세스의 페이지 테이블에 접근하기 위해 테이블 기준 레지스터(page-table base register)와 페이지 테이블 길이 레지스터(page-table length register)를 사용함. 페이지 테이블 기준 레지스터는 메모리 내에서의 페이지 테이블의 시작 위치, 페이지 테이블 길이 레지스터는 페이지 테이블의 크기를 보관함.
페이징 기법에서는 주소 변환을 위해 페이지 테이블에 접근하는 것과 변환된 주소로 실제 데이터에 접근 하는 것, 두 번의 메모리 접근연산을 필요로 함. 메모리에 한 번 접근하기 위해 매번 두 번 접근하는 오버헤드가 뒤따름. 이를 줄이고 메모리 접근 속도를 향상시키기 위해 TLB(Translation Look-aside Buffer)라는 고속의 주소 변환용 하드웨어 캐시가 사용되기도 함.
TLB에는 페이지 테이블에 모든 주소를 담지 않고 빈번히 참조되는 페이지에 대한 주소 변환 정보만 담음.
즉 TLB에 요청받은 페이지 번호가 존재한다면 곧바로 대응하는 물리적 메모리의 프레임 번호를 얻고, 존재하지 않는 경우에는 메인 메모리에 있는 페이지 테이블로부터 프레임 번호를 알아내야 함.
주소 변환 정보는 프로세스별ㄹ로 다르기 때문에 문맥교환 시 이전 프로세스의 주소 변환 정보를 담던 TLB 내용은 모두 지워야 함.
페이지 테이블에는 하나의 프로세스를 구성하는 모든 페이지에 대한 주소 변환 정보가 페이지 번호에 따라 순차적으로 들어 있어, 페이지 번호가 주어지면 테이블의 시작 위치에서 페이지 번호만큼 떨어진 항목에 바로 접근해 해당 페이지에 대응하는 프레임 번호를 얻음.
TLB를 사용한 주소 변환의 경우 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되어야 함. 또한 요청한 정보가 TLB에 있는지 확인하기 위해 TLB의 모든 항목(entry)을 다 찾아봐야하는 오버헤드가 발생하는데, 이를 줄이기 위해 일반적으로 병렬탐색(parallel search)이 가능한 연관 레지스터(associative register)를 사용함.

## 3) 계층적 페이징
2단계 페이징(two-level paging)기법에서는 주소 변환을 위해 외부 페이지 테이블(puter page table)과 내부 페이지 테이블(inner page table)의 두 단계에 걸친 페이지 테이블을 사용함.
페이지 테이블에 사용되는 메모리 공간은 줄어드나, 접근해야 하는 페이지 수의 증가로 시간적 손해가 생김.
프로세스의 논리적 주소를 두 종류의 페이지 번호(p1, p2)와 오프셋(d)으로 구분함. <p1,p2,d>의 형태로 표시하면, 외부 페이지 테이블로부터 p1만큼 떨어진 위치에서 내부 페이지 테이블 주소를 얻고, 거기서 p2만큼 떨어진 위치에 요청된 페이지가 존재하는 프레임을 얻고, 거기서 d만큼 떨어진 곳에서 원하는 정보에 접근 가능함.
메모리 접근에 의한 시간적 오버헤드를 줄이기 위해 TLB를 사용하는 것이 효과적임.

## 4) 역페이지 테이블(inverted page tale)
물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 주는 방식임. 논리적 주소가 아닌 물리적 주소에 페이지 테이블을 만들어 시스템 전체(system-wide)에 페이지 테이블을 하나만 두는 방법임. 페입지 테이블의 각 항목은 프로세스 번호(pid)와 그 프로세스 내의 논리적 페이지 번호(p)를 담음.
역페이지 테이블은 일반적으로 메모리에 유지하는 대신 연관 레지스터(associative register)에 보관해 테이블 전체 항목에 대한 병렬 탐색을 가능하게 해 시간적 효율성을 높임.

## 5) 공유 페이지
공유 코드(shared code)는 메모리 공간의 효율적 사용을 위해 여러 프로세스가 공통으로 사용할 수 있도록 작성된 코드. 공유 코드는 재진입 가능 모드(re-entrant code) 또는 순수 코드(pure code)라고도 불리며 읽기 전용의 특성을 가짐. 
공유페이지는(shared page)는 공유 코드를 담고 있는 페이지. 물리적 메모리 하나만 적재되어 메모리를 효율적으로 사용함. 공유페이지는 모든 프로세스의 논리적 주소 공간에서 동일한 위치에 존재하며 동일한 페이지 번호를 가져야 함.
대비되는 개념인 사유 페이지(private page)는 프로세스들이 공유하지 않고 프로세스별로 독자적으로 사용하는 페이지를 말함.

## 6) 메모리 보호
페이지 테이블의 각 항목에는 메모리 보호를 위한 보호비트(protection bit)와 유효-무효 비트(valid-invalid bit)를 두고 있음.
보호비트는 각 페이지에 대한 접근 권한 내용을 담음. '누구'에 해당하는 접근 권한을 설정할 필요는 없으며, 각 페이지에 대해 '어떠한' 접근을 어용하는지의 정보가 보호비트에 저장됨.
유효-무효 비트는 해당 페이지 내용의 유효 유무를 담고 있음. 유효로 세팅되어 있으면 메모리 프레임에 그 페이지가 존재함들 뜻하며 접근이 허용됨. 무효의 경우 프로세스가 그 주소 부분을 사용하지 않거나, 해당 페이지가 물리적으로 올라와 있지 않고 백킹스토어에 존재함.

# 5. 세그먼테이션(segmentation)
세그먼테이션은 프로세스의 주소 공간을 의미 단위의 세그먼트(segment)로 나누어 물리적 메모리에 올리는 기법.
프로세스를 구성하는 주소 공산은 일반적으로 코드, 데이터, 스택 등의 의미 있는 단위들로 구성되며 세그먼트는 주소 공간을 기능 또는 의미 단위로 나눈 것을 뜻함. 프로세스의 주소 공간 전체를 하나의 세그먼트로 볼 수도 있으며, 일반적으론 코드, 데이터, 스택 등의 기능 단위로 세그먼트를 정의함.
의미를 가질 수 있는 논리적인 단위(logical unit)로 나누기 때문에 크기가 균일하지 않음.
메모리에 나누어 적재되긴 하지만 크기가 균일하지 않아 메모리 적재 시 부가적인 관리 오버헤드가 뒤따름.
논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘며 세그먼트 번호는 해당 논리적 주소가 프로세스 주소 공간 내 몇 번째 세그먼트에 속하는가 이며, 오프셋은 그 세그먼트 내에서 얼마만큼 떨어져 있는지에 대한 정보를 뜻함.
주소 변환을 위해 세그먼트 테이블을 사용하는데 각각 기준점(base)와 한계점(limit)이라는 항목을 가짐. 기준점은 세그먼트의 시작위치 이며 한계점은 세그먼트의 길이를 말함. 
주소 변환 시 세그먼트 테이블 기준 레지스터(STBR)와 세그먼트 테이블 길이 레지스터(STLR)를 사용함. 세그먼트 테이블 기준 레지스터는 CPU에서 실행중인 프로세스의 세그먼트 테이블이 메모리의 어느 위시에 있는지 그 시작주소를 담고, 세그먼트 테이블 길이 레지스터는 프로세스의 주소 공간이 몇 몇개의 세그먼트로 구성되는지 그 개수를 나타냄.
페이징 기법과 마찬가지로 보호비트와 유효비트를 가짐. 보호비트는 각 세그먼트들의 읽기/쓰기/실행 등의 권한 여부를 나타내며 유효비트는 각 세그먼트의 주소 변환 정보가 유효한지(물리적 메모리 적재 여부) 나타냄.
공유 세그먼트 개념도 유효함. 이 세그먼트는 모든 프로세스의 주소 공간에 동일한 논리적 주소에 위치해야 함.
공유와 보안의 측면에서 페이징 기법에 비해 효과적이나, 길이가 균일하지 않아 메모리 관리에서 외부조각이 발생하며 어느 가용 공간에 할당할 지 결정하는 문제가 발생함. 할당 방식에 대해 최초적합 방식과 최적적합 방식이 있음.

# 6. 페이지드 세그먼테이션(paged segmentation)
프로그램을 의미 단위의 세그먼트로 나누는데, 반드시 동일한 크기 페이지들의 집합으로 구성하는 것. 물리적 메모리에 적재하는 단위는 페이지 단위로 함.
주소 변환을 위해 외부 세그먼트 테이블과 내부 페이지 테이블을 이용함.
<세그먼트 번호, 오프셋>으로 구성된 논리적 주소를 물리적 주소로 변환하는 과정은 논리적 주소의 상위 비트인 세그먼트 번호로 세그먼트 테이블의 해당 항목에 접근함. 세그먼트의 길이와 세그먼트의 페이지 테이블 시작 주소를 받으며 세그먼트의 길이를 넘는지, 오프셋 값이 더 큰지 체크 한 후 이상이 없으면 오프셋 값을 상위/하위 비트로 나누어 상위 비트는 세그먼트 내 페이지 번호로 사용하고 하위 비느틑 페이지 내의 변위로 사용함.

