# 운영체제와 정보기술의 관리 7장 메모리 관리

메모리를 구분하기 위해 주소가 존재하는데, 여기서 주소란 서로 다른 위치를 구분하기 위한 일련의 숫자.
컴퓨터 시스템은 32비트 혹은 64비트의 주소체계를 사용. 컴퓨터에서는 byte 단위로 메모리 주소를 부여하기 때문에 32비트의 주소체계의 경우 2^32byte만큼의 메모리 공간에 주소를 할당함.
컴퓨터상의 주소는 효율적 운영을 위해 마치 실제 행정구역처럼 묶어서 사용함.
보통 4KB(2^12byte) 단위로 묶어서 페이지(page)라는 행정구역을 만들고 나머지 2^12byte에서 주소를 나타냄.

# 1. 주소 바인딩
프로그램이 메모리에 적재되면 그 프로그램을 위한 독자적인 주소 공간이 생성되며 이 주소를 논리턱 주소(logical address) 혹은 가상 주소(virtual address)라고 함. CPU는 논리적 주소에 근거해 명령을 실행함. 논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지부터 시작됨. 물리적 주소(physical address)는 물리적 메모리에 실제로 올라가는 위치를 말하며, 물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고 높은 주소영역에는 사용자 프로세스들이 올라감.
CPU가 기계어 명령 수행을 위해 논리적 주소를 통해 메모리를 참조하면 논리적 주소가 물리적 주소의 어느 위치에 매핑되었는지 확인해야 함. 프로세스의 논리적 주소를 물리적 메모리 주소로 연결하는 작업을 주소 바인딩(address binding)이라고 함.

컴파일 타임 바인딩(compile time binding)
- 물리적 메모리 주소가 프로그램을 컴파일할 때 결정
- 프로그램이 절대주소로 적재된다 하여 절대코드(absolute code)를 생성하는 바인딩 방식이라고도 함.
- 물리적 메모리의 위치를 변경하려면 컴파일을 다시해야 하기 때문에 비현실적이고 시분할 컴퓨팅 환경에선 잘 사용하지 않음.

로드 타임 바인딩(load time binding)
- 프로그램의 실행이 시작될 때 물리적 메모리가 결정
- 로더(loader)의 책임하에 물리적 메모리 주소가 부여되며 종료될 때까지 물리적 메모이상의 위치가 고정
- 로더란 사용자 프로그램을 메모리에 적재시키는 프로그램이며 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 방식

실행시간 바인딩(execution time binding, run time binding)
- 프로그램 실행 이후에도 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식
- CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리 어디에 존재하는지 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검해야 함
- 기준 레지스터와 한계 레지스터를 포함해 MMU(Memory Management Unit: 메모리 관리 유닛)가 있어야 함.
- MMU는 논리적 주소와 물리적 주소를 매핑해주는 하드웨어 장치

MMU를 사용한 기본적인 주소 변환을 수행하는 MMU 기법(MMU acheme)
CPU가 논리적 주소를 참조할 때 그 주소값에 기준 레지스터 값을 더해 물리적 주소 값을 얻어냄. 이때 기준 레지스터는 재배치 레지스터(relocation register)라고도 함. MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재된 것으로 가정함. MMU 기법에서 사용자 프로그램이나 CPU는 논리적 주소만 다루며 물리적 주소는 모르고, 알 필요도 없음. 여기서 논리적 주소는 물리적 주소의 시작위치인 재배치 레지스터 값에서 얼마나 떨어져 있는지를 나타내는 오프셋(offset) 개념으로 생각할 수 있음.
MMU 방식을 활용해 주소 변환을 했을 경우 그 결과가 해당 프로그램의 주소 공간을 벗어나는 걸(메모리 보안이 이루어지지 않는 걸) 방지하기 위해 한계 레지스터(limit register) 를 사용함. 한계 레지스터는 프로세스가 자기 주소 공간을 넘어서는 메모리 참조를 하는지 체크하는 용도로 사용되며, CPU에서 수행 중인 프로세스의 논리적 주소의 최대값(프로세스의 크기)를 담고 있음. CPU가 메모리 참조 요청을 했을 때 그 주소가 한계 레지스터보다 큰지 먼저 체크하여 메모리 보안이 이루어짐. 

# 2. 메모리 관리와 관련된 용어
## 1) 동적 로딩(dynamic loading)
여러 프로그램이 동시에 메모리에 올라가 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위한 기법	
프로세스가 시작될 때 프로세스의 주소 공간 전체를 메모리에 올리지 않고 해당 부붑ㄴ이 불릴 때 그 부분만 메모리에 적재하는 방식을 사용함. 즉 실행에 필요한 부분이 실제로 불릴 떄마다 메모리에 적재하는 방식
실제 프로그램의 코드 중 상당부분은 오류 처리루틴 같이 특별한 경우에만 가끔식 사용되는 방어용 코드임. 이를 다 메모리에 올리면 낭비이기 때문에 동적 로딩 방식을 사용함.
동적 로딩은 운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하며 운영체제가 라이브러리를 통해 지원할 수도 있음.

## 2) 동적 연결(dynamic linking)
**연결(linking)**이란 프로그래머가 작성한 소스코드를 컴파일하여 생성된 목적 파일(object file)과 이미 컴파일된 라이브러리 파일(library file)들을 묶어 하나의 실행파일을 생성하는 과정.
동적 연결은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의실행 시점까지 지연시키는 방법.
동적 연결과 반대되는 개념인 정적 연결(static linking)은 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성됨. 실행파일의 크기가 상대적으로 크며 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재하므로 물리적 메모리 낭비가 심함.
동적 연결에서는 라이브러리가 실행 시점에 연결되기 때문에 실행 파일에 라이브러리 코드가 포함되지 않음. 프로그램이 실행되면서 라이브러리 함수를 호출할 때 연결이 이루어짐.
이를 위해 실행파일의 라이브러리 호출 부부에 해당 라이브러리의 위치를 찾기 위한 스텁(stub)이라는 작은 코드를 둠. 스텁을 통해 해당 라이브러리가 메모리에 이미 있는 지 찾아 있을 경우 그 주소의 메모리 위치를 직접 참조하며, 없을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리에 적재한 후 실행.
동적 연결은 라이브러리를 메모리에 한 번만 기재해 메모리 사용 효율을 높일 수 있으며, **동적 연결 기법은 운영체제의 지원이 필요함.**

## 3) 중첩(overlays)
중첩이란 프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법. 동적 로딩과 유사한 개념이지만 중첩은 초창기 컴퓨터 시스템에서 하나의 프로세스조차 메모리에 한꺼번에 올릴 수 없을 때 당장 필요한 일부분만 메모리에 올려 실행하고 해당 부분이 끝난 후 나머지 부분을 올려 실행한느 기법. 즉 물리적 메모리의 크기가 작을 때 분할하여 메모리에 올리는 것.
중첩은 운영체제 지원 없이 구현되어야 했으며, 초창기 시스템에서는 프로그래머가 직접 구현했다 하여 수작업 중첨(manual overlays)라고도 부름.

## 4) 스와핑(swapping)
메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려 놓는 것. 이때 스왑영역은 백킹스토어(backing store)라고도 부르며 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역. 스왑영역은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간.
스왑영역은 다수의 사용자 프로세스를 담을 만큼 충분한 저장공간과 어느 정도의 접근 속도가 보장되어야 함. 스와핑은 프로세스가 종료되어 주소 공간을 디스크로 내쫒는 것이 아닌 특정한 이유로 수행 중인 프로세스의 고간을 일시적으로 내려 놓는 것.
스와핑에서 일러나는 작업의 방향에 따라 디스크에서 메모리로 올리는 작업을 스왑인(swap in), 메모리에서 디스크로 내리는 작업을 스왑 아웃(swap out)이라 부른다.

### 스와핑의 과정
스와퍼(swapper)라는 중기 스케줄러에 의해 스왑 아웃시킬 프로세스를 선정함. 스왑 아웃 대상인 프로세스는 현재 메모리에 올라가 있는 주소 공간의 내용을 통쨰로 기스크 스왑 영역으로 스왑아웃 시킴.

스와핑의 가장 중요한 역할은 메모리에 존재하는 프로세스의 수를 조절하는 것. 스와핑을 통해 다중 프로그래밍의 정도(degree of multiprogramming)를 조절할 수 있음.
프로세스가 너무 많으면 프로세스당 할당되는 메모리의 양이 적어져 시스템 전체의 성능이 떨어지기 떄문에 이를 해결하고자 몇몇 프로그램을 통째로 내리므로써 남은 프로그램에 대해 적절한 메모리 공간을 제공함. 충분히 실행된 후 스왑아웃한 프로그램을 다시 올리는 것.

컴파일 방식 바인딩과 로드 타임 바인딩 방식에서는 스왑 아웃 된 프로세스가 다시 스왑 인될 때 원래 존재했던 메모리 위치로 다시 올라가야 하지만 실행시간 바인딩 기법에서는 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있음. 스와핑에서는 디스크의 스왑 영역에 프로세스의 주소 공간이 순차적으로 저장되기 때문에, 스와핑에 소요되는 시간은 디스크의 탐색시간(seek time)이나 최전지연시간(rotation latency)보다 디스크 섹터에 실제 데이터를 읽고 쓰는 전송(transfer time)이 대부분을 차치함.

# 3. 물리적 메모리의 할당 방식
물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉨.

운영체제 상주 영역은 언터럽트 벡터와 함께 물리적 메모리의 낮은 영ㅇ역을 사용하며 커널이 위치함.
사용자 프로세스 영역은 높은 메모리 주소 영역을 사용하며 여러 사용자 프로세스들이 적재되어 실행됨.

사용자 프로세스 영역의 관리 방법은 프로세스를 메모리에 올리는 방식에 따라 연속할당(contigueous allocation) 방식과 불연속할당(noncontiguous allocation) 방식으로 나뉨.

## 1) 연속할당 방식
프로세스를 메모리에 올릴 때 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 연속적인 공간에 올리는 방식. 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 함. 분할을 관리 하는 방법으로 고정분할방식과 가변분할방식으로 나눔.

### 고정분할 방식(fixed partition allocation)
물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누고 각 분할에 하나의 프로세스를 적재해 실행하는 방식. 분할의 크기는 동일할 수 있고 다르게 할 수 도 있으나 하나의 분할된 영역에 하나의 프로그램만 적재 가능함.
따라서 고정분할 방식은 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기또한 제한되어 융통성이 떨어짐.
고정분할 방식은 외부조각과 내부조각이 발생할 수 있음.
외부조각은 프로그램의 크기가 분할 크기보다 커 해달 분할의 공간이 비어있어도 사용될 수 없는 작은 분할을 말함. 해당 분할보다 작은 프로그램이 생기면 적재될 수도 있음.
내부조각은 프로그램이 적재되고도 남은 메모리 공간을 말함. 이는 남는 공간만큼의 프로그램이 있어도 사용할 수 없어 메모리가 낭비되는 것임.

### 가변분할 방식(variable partition allocation)
메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식.
내부조각이 발생할 일은 없으나 외부조각은 발생할 수 있음.
가변분할 방식에서 중요한 문제 중 하나로 동적 메모리 할당 문제(dynamic storage-allocation problem)가 있는데, 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내 가용 공간 중 어떤 위치에 올릴 것인지 결정하는 문제. 가용 공간이란 사용되지 않은 메모리 공간으로 메모리 내 산발적으로 존재할 수 있음.
가용 공간들을 효율적으로 관리하기 위해 훈영체제는 이미 사용 중인 메모리 공간과 사용하고 있지 않은 가용공간에 대한 정보를 각각 유지해야 함.

동적 메모리 할당 문제 해별 방법
- 최초적합 방법(first-fit) : 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당하는 것. 가용 공간이 프로그램 크기보다 작으면 건너뛰고, 그렇지 않은 최초 공간에 프로그램을 올리는 방법으로 모든 공간을 확인하지 않아 시간적 측면에서 효율적임.
- 최적적합 방법(best-fit) : 크기가 n 이상인 가장 작은 가용 공간을 찾아 그곳에 새로운 프로그램을 할당하는 것. 가용공간이 크기순으로 정령되어 있지 않은 경우 모든 가용 공간을 탐색해 시간적 오버헤드가 발행하고 다수의 매우 작은 가용공간들이 형성될 수 있음. 공간적 측면에선 가장 효율적임.
- 최악적합 방식(worst-fit) : 가용 공간 중 가장 큰 곳에 새로운 프로그램을 할당하는 것. 모든 가용 공간 리스트를 탐색하는 오버헤드가 발생함. 큰 가용 공간을 먼저 소진한다는 단점이 있음.

가변분할 방식에서 발생하는 외부조각 문제를 해결하기 위한 방법으로 컴팩션이 있음. 컴팩션(compaction)은 물리적 메모리 중에서 프로세스가 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아 하나의 큰 가용공간을 만드는 방법임. 수행 중인 프로세스의 메모리상의 위치를 상당 부분 이동시켜 비용이 매우 많이 드는 작업임. 가급적 적은 수의 메모리 이동으로 효율적인 컴팩션을 수행하는 방법이 필요하나 이론적으로 매우 복잡함. 또한 컴팩션은 수행 중인 프로세스의 물리적 메모리 위치를 옮겨야 하므로 실행시간 바인딩 방식이 지원되는 환경에서만수행 가능함.

## 2) 불연속할당 기법
하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법.
하나의 프로그램을 분할하는 기준에 따라 동일한 크기고 나누는 페이징 기법과, 크기는 일정하지 않지만 의미 단위로 나누어 메모리에 올리는 세그먼테이션(segmentation) 기법, 그리고 세그먼테이션을 기본으로 하며 동일 크기의 페이지로 나누는 페이지드 세그먼테이션(paged segmentation) 기법 등이 있음.





