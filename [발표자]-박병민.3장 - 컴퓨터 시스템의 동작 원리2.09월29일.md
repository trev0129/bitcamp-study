# 3장 컴퓨터 시스템의 동작 원리

## 6. DMA

원칙적으로 **메모리는 CPU에 의해서만 접근 가능한 장치**이기 때문에 CPU 외의 장치가 메모리의 데이터에 접근하기 위해선 **인터럽트를 발생**시켜 CPU가 대행하는 방식만 가능하다. 

모든 메모리 접근 연산이 CPU에 의해서만 이루어지면 입출력장치가 메모리 접근을 원할 때마다 인터럽트를 발생시켜 CPU 사용의 효율성이 떨어진다.

→ 이를 극복하기 위해 **CPU 이외에 메모리 접근이 가능한 장치**가 하나 더 있는데, 이것이 DMA이다.

![img](https://blog.kakaocdn.net/dn/dQqy4c/btrnTD9Jw6E/uWgym6OzxP6jpB30YKUZW1/img.png)

### **DMA(Direct Memeory Access)**

- 일종의 컨트롤러로서, CPU가 자주 인터럽트 당하는 것을 막아준다.
- 이를 사용하면 **로컬버퍼에서 메모리로 읽어오는 작업을 DMA가 대행**함으로써 CPU가 하던 작업을 멈추고 인터럽트를 처리할 필요가 없다.
- DMA는 바이트(byte)단위가 아니라 **블록(block)**이라는 큰 단위로 정보를 메모리로 읽어온 후 CPU에게 인터럽트를 발생시켜 해당 작업의 완료를 알린다.
- CPU에 발생하는 인터럽트의 빈도를 줄여 효율적으로 관리하고 입출력 연산속도를 높인다.

## 7. 저장장치의 구조

### 컴퓨터 시스템을 구성하는 저장장치

- **주기억장치** : **메모리**(전원이 나가면 저장된 내용이 모두 사라지는 휘발성(volatile)를 가진 RAM을 매체로 사용하는 경우가 대부분
- **보조기억장치** : **마그네틱 디스크**를 주로 사용(전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성을 가짐), 플래시 메모리, CD, 메그네틱 테이프 등

### 보조기억장치의 용도

- **파일 시스템(file system)** : 휘발성 매체인 메모리는 전원이 나가면 정보를 유지하지 못해 비휘발성 매체인 디스크에 파일 형태로 저장한다.
- **스왑 영역(swap area)** : 메모리의 크기가 한정적이기 때문에 운영체제가 프로그램에 당장 필요한 부분만 메모리에 올리고 **그렇지 않은 부분은 디스크의 스왑 영역**에 내려놓게 된다. 디스크에 내려놓는 일을 **스왑 아웃(swap out)**시킨다고 하며, 다시 필요할 때에는 다시 메모리 영역으로 올린다. **스왑영역은 메모리의 연장 공간으로서의 역할**을 한다.

### 보조기억장치 - 하드디스크의 물리적 구조

![img](https://velog.velcdn.com/images%2Ftaelee%2Fpost%2F93ed7821-f5a2-4efb-9a2f-348d8af23c89%2Fimage.png)

여러 개의 마그네틱 원판들이 있고 **암(arm)**이 원판에 저장된 데이터를 읽고 쓰는 방식으로 동작한다.

디스크 원판의 표면은 **트랙(track)**으로 나뉘고, 각 트랙은 **섹터(sector)**로 나뉜다. 

## 8. 저장장치의 계층적 구조

컴퓨터 시스템을 구성하는 저장장치는 단계적인 계층 구조로 이루어진다. 당장 필요한 정보는 빠른 저장장치에, 그렇지 않은 정보는 상대적으로 느린 저장장치에 보관하게 된다.

이미지

최상위의 CPU 내부에 존재하는 **레지스타(register)**, **캐시 메모리(cache memory)**, **메인 메모리(main memory)** 등의 휘발성 저장장치가 상위에 존재한다. 메인 메모리보다 아래 부분을 구성하는 저장장치 계층은 비휘발성 저장장치이다.

![img](https://images.velog.io/images/jehjong/post/c00204d2-186d-4ad1-aefb-f6260e129ecb/image.png)

**상위 저장장치 계층으로 갈수록 접근속도가 빠르지만 용량은 상대적으로 적다.** 캐싱기법을 활용해 당장 필요한 정보만 선별적으로 저장하면 하위에 있는 큰 용량의 저장장치와 비슷한 성능효과를 낼 수 있다.

**캐싱 기법**이란 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법이다. 상태적으로 느린 저장장치에 있는 내용중 **당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장**하여 전체적인 성능이 향상된다.

이는 컴퓨터 내의 데이터나 프로그램을 구성하는 부분이 균일하게 사용되는  것이 아니라 일부분이 더 자주 집중적으로 사용되기 때문이다.

캐싱 기법을 다양한 저장장치 계층에서 활용함으로서 적은 용량의 상위 저장장치만으로 대부분의 경우 빠른 속도의 성능을 얻을 수 있다.

## 9. 하드웨어의 보안

### 커널모드와 사용자모드

각 프로그램이 **다른 프로그램의 실행을 방해**하거나 **프로그램 간의 충돌** 문제를 방지하기 위해 하드웨어에 대한 각종 보안기법이 필요하다.

하드웨어적 보안을 위해 운영체제는 **커널모드(kernel mode, system mode)**와 **사용자모드(user mode)**의 두 가지 모드를 지원한다.

- **커널모드** : 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드로 **모든 종류의 명령**을 다 실행할 수 있다.
- **사용자모드** : 일반 **사용자 프로그램이 실행**되며 **제한적인 명령만 수행** 가능하다. 시스템에 중요한 영향을 미치는 연산은 커널모드에서만 가능하다.

### 모드비트

그러나 사용자 프로그램이 프로그램 내에서 중요한 연산을 수행하면 제어가 소용 없게 된다. 사용자 프로그램이 CPU를 가지고 있는 동안 운영체제는 자신의 코드를 시행하지 못해 감시할 방법이 없기 때문이다.

→ 이를 방지하고자 하드웨어적 지원이 필요한데, 컴퓨터 시스템은 CPU내부에 모드비트(mode bit)를 두어 사용자 프로그램을 감시한다.

**모드비트** : 모드 확인을 위한 비트로 **0이면 커널모드, 1이면 사용자 모드**이다. CPU는 보안과 관련된 명령을 수행하기 전에 항상 모드비트르 조사해 그 값이 0일 때만 명령을 수행한다.

- 운영체제 - 사용자 프로그램
    
    운영체제가 **사용자 프로그램에게 CPU의 제어권을 넘길 때 모드비트를 1로 세팅**해 넘기고 사용자 프로그램에서 하드웨어 접근 등 보안이 필요한 중요한 명령 수행 시 시스템 콜을 통해 운영체제가 대행할 것을 요청할 경우 CPU제어권이 운영체제에게 넘어가게 된다.
    

- 인터럽트 발생
    
    **인터럽트가 발생할 때 모드비트는 자동으로 0이 세팅**되어 운영체제가 서비스에 필요한 모든 종류의 명령을 수행할 수 있다. 요청된 작업이 끝난 후에는 모드비트를 1로 만들어 CPU를 넘겨준다.
    

시스템 보안과 관련된 명령들을 **특권명령**이라 하며 이는 **커널모드에서 운영체제에 의해서만 수행** 가능하다.

- 입출력 명령
    
    **모든 입출력 명령은 특권명령으로 규정**하여 사용자 프로그램이 직접 입출력을 할 수 없다. 운영체제에게 시스템 콜로 요청하여 운영체제가 대신 수행할 수 있다.
    
    **인터럽트 벡터**의 특정 위치를 통해 해당 인터럽트 처리루틴으로 이동한다. 이 때 인터럽트 하드웨어에 의해 모드비트가 0으로 세팅되어 운영체제는 입출력을 수행할 수 있게 된다.
    
    특히 운영체제는 입출력 요청이 올바른 요청인지 확인한 후 입출력을 실행하기 때문에 파일에 대한 보안을 유지할 수 있다.
    
    입출력이 완료되면 CPU제어권을 다시 사용자 프로그램에 넘길 수 있게 되며 시스템 콜 이후 명령을 수행한다.

    ![img](https://images.velog.io/images/jehjong/post/938ebcd9-b20f-4ee9-877b-8b904f33547e/image.png)
    

## 10. 메모리 보안

메모리에는 여러 프로그램이 동시에 올라가서 실행되기 때문에 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 위험이 있다.

인터럽트 벡터와 인터럽트 처리루틴이 있는 곳은 각별안 보안이 필요하다. 운영체제만 수행할 수 있는 특권 명령을 보안성이 침해되는 명령으로 변형할 수 있기 때문이다.

→ 이를 해결하기 위해 **기준 레지스터(base register)와 한계 레지스터(limit register)**를 사용해 프로그램이 접근하려는 메모리 부분이 합법적인지 체크하여 보호한다. 

### 기준 레지스터와 한계 레지스터

![img](https://images.velog.io/images/jehjong/post/3648480c-80d4-44d1-9365-cf9aac7b329c/image.png)

- **기준 레지스터** : 어떤 프로그램이 실행되는 동안 **합법적으로 접근할 수 있는 메모리상의 가장 작은 주소**를 보관한다.
- **한계 레지스터** : 프로그램이 **기준 레지스터값부터 접근할 수 있는 메모리의 범위(프로그램의 길이)**를 보관하고 있다.

메모리 접근 연산이 있을 때, **하드웨어적으로 합법적인 범위**의 위치에 접근하는지 체크한다. **기준레지스터로부터 기준 레지스터+합법 레지스터값 사이의 주소영역**에만 접근 가능하며, 범위를 벗어나면 불법적인 메모리 접근으로 **예외상황**을 발생시킨다.

**예외상황** : 운영체제에 **소프트웨어 인터럽트**를 발생시켜 CPU제어권을 운영체제로 이양시키고 해당 프로그램을 강제 종료시킨다. 

→ 이러한 메모리 보호 기법은 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 단순화된 메모리 관리 기법을 사용하는 경우에 한정된 설명이며, 하나의 프로그램이 여러 영역에 나뉘어 위치하는 페이징(paging)기법 등에 대해선 7장에서 자세히 다루어질 예정이다.

![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbHO5du%2FbtrnVw9Pg9n%2FuSvUc8yQ7TBo2IbAtRFxJ1%2Fimg.png)

### 메모리 접근 연산

메모리 접근 연산은 **사용자 프로그램이 CPU를 가지고 있는 동안 수행할 수 있는 연산**이므로 특권명령은 아니지만 메모리에 접근하기 전에 **하드웨어적으로 접근의 합법여부를 체크**하여 보호한다.

사용자모드에선 기준 레지스터와 한계 레지스터를 사용해 메모리를 보호하고, 커널모드에서는 메모리에 무제한으로 접근이 가능하다.

메모리 접근 명령은 특권명령이 아니지만, 기준 레지스터와 한계 레지스터의 값을 세티하는 연산은 특권명령으로 규정해야 한다.

## 11. CPU 보호

CPU가 프로그램에 독점되는 것을 막기 위해 운영체제는 타이머(timer)라는 하드웨어를 사용한다. 

### 타이머

- **정해진 시간이 지나면 인터럽트를 발생**시켜 운영체제가 CPU의 제어권을 획득할 수 있도록 한다.
- 타이머는 시간 단위로 셋팅하며 매 클럭 틱(clock tick) 때마다 1씩 감소해 0이되면 인터럽트가 발생한다.
- 타이머에 의해 발생되는 인터럽트 처리루틴 :  CPU를 점유하고 명령을 실행중인 프로그램으로부터 CPU를 빼앗아 다른 프로그램에게 이양하는 것
- **타이머의 값 세팅 명령을 로드 타이머(load timer)**라고 하며 **특권명령**에 속한다.
- 타이머는 **시분할 시스템에서 현재 시간을 계산**하기 위해서도 사용된다.

## 12. 시스템 콜을 이용한 입출력 수행

사용자 프로그램이 디스크 파일에 데이터를 쓰거나, 키보드로부터 입력을 받거나 수행 결과를 화면에 출력하는 행위 등은 모두 특권명령인 입출력 명령에 해당한다.

사용자 프로그램은 운영체제 코드로 구현된 입출력 명령을 직접 수행할 수 없다. 그 대신 운영체제에게 일종의 소프트웨어 인터럽트

인 **‘시스템 콜’**이라는 서비스 대행 요청을 한다.

시스템 콜 → 트랩 발생 → OS가 CPU제어권 획득 → 해당 콜의 처리 루틴으로 이동 → 정의된 명령 수행